@using HSMServer.Core.Model
@using HSMServer.Core.Model.Authentication
@using HSMServer.Model.TreeViewModels
@model HSMServer.Model.TreeViewModels.TreeViewModel

@{
    UpdateFilteredSensors();
}

<ul>
    @foreach (var (_, node) in Model.Nodes)
        @if (node.Parent == null && node.IsAvailableForUser && node.InnerFilteredSensorsCount != 0)
            @await Html.PartialAsync("_TreeNode", node)
</ul>

@{
    bool IsVisibleSensor(SensorNodeViewModel sensor, TreeUserFilter filter)
    {
        bool IsDefault() =>
            !(filter.IsBlockedSensors || filter.HasTelegramNotifications || filter.IsIgnoredSensors
                 || filter.HasOkStatus || filter.HasWarningStatus || filter.HasErrorStatus
                 || filter.HasUnknownStatus) && sensor.HasData;

        bool IsStatusFiltering() =>
            filter.HasOkStatus || filter.HasWarningStatus || filter.HasErrorStatus || filter.HasUnknownStatus;

        bool SensorHasVisibleStatus() =>
            sensor.Status switch
            {
                SensorStatus.Ok => filter.HasOkStatus,
                SensorStatus.Warning => filter.HasWarningStatus,
                SensorStatus.Error => filter.HasErrorStatus,
                SensorStatus.Unknown => filter.HasUnknownStatus,
                _ => false
            };


        if (IsDefault())
            return true;

        bool isStatusFiltering = IsStatusFiltering();
        bool isEmptyFiltering = filter.IsEmptyHistory;
        bool isNotiificationsFiltering = filter.HasTelegramNotifications;

        bool? isStatusPassed = isStatusFiltering ? SensorHasVisibleStatus() : null;
        bool? isEmptyPassed = isEmptyFiltering ? !sensor.HasData : null;
        bool? isNotificationsPassed = isNotiificationsFiltering ? sensor.IsNotificationsEnabled : null;

        if (isStatusPassed.HasValue && !isStatusPassed.Value)
            return false;

        if (isEmptyPassed.HasValue && !isEmptyPassed.Value)
            return false;

        if (isNotificationsPassed.HasValue && !isNotificationsPassed.Value)
            return false;

        return true;
    }

    void UpdateFilteredSensors()
    {
        foreach (var (_, node) in Model.Nodes)
            if (node.Parent == null)
                Recursion(node);
    }

    void Recursion(ProductNodeViewModel node)
    {
        void UpdateTimeAndStatus()
        {
            var sensors = node.FilteredSensors;
            var nodes = node.Nodes.Values.ToList();

            var sensorMaxTime = DateTime.MinValue;
            var nodeMaxTime = DateTime.MinValue;
            var statusFromSensors = SensorStatus.Ok;
            var statusFromNodes = SensorStatus.Ok;

            if (sensors.Count > 0)
            {
                sensorMaxTime = sensors.Max(x => x.UpdateTime);
                statusFromSensors = sensors.Max(s => s.Status);
            }
            if (nodes.Count > 0)
            {
                nodeMaxTime = nodes.Max(x => x.UpdateTime);
                statusFromNodes = nodes.Max(n => n.Status);
            }

            node.UpdateTime = sensorMaxTime > nodeMaxTime ? sensorMaxTime : nodeMaxTime;
            node.Status = statusFromNodes > statusFromSensors ? statusFromNodes : statusFromSensors;
        }


        int visibleSensorsCount = 0;
        node.FilteredSensors = new List<SensorNodeViewModel>(node.Sensors.Count);
        node.InnerFilteredSensorsCount = 0;

        foreach (var (_, sensor) in node.Sensors)
            if (IsVisibleSensor(sensor, ((User)User).TreeFilter))
                node.FilteredSensors.Add(sensor);

        node.InnerFilteredSensorsCount = node.FilteredSensors.Count;

        foreach (var (_, child) in node.Nodes)
        {
            Recursion(child);
            visibleSensorsCount += child.InnerFilteredSensorsCount;
        }

        node.InnerFilteredSensorsCount = visibleSensorsCount + node.FilteredSensors.Count;

        UpdateTimeAndStatus();
    }
}